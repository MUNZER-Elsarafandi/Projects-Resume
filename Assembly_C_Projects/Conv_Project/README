Hiii, Letâ€™s Chat About My 68000 to x86_64 Assembly Project!
So, Whatâ€™s This Thing All About?
Heyy! Iâ€™m Munzer Elsarafandi, a Year 2 student at SETU Carlow studying Software Development and Cyber Security, and this is my Project II for our "Assembly and C Module." I had to take this 68000 assembly program and turn it into x86_64 assembly, and oh my gosh, it was such a journey! My programâ€™s called sum-program.asm, and itâ€™s supposed to ask you for 2 numbers each round, do that for 3 rounds, handle positive, negative, and zero values, keep a running total, and show you the sums along the way and the final result at the end. I also had to make sure itâ€™s secureâ€”like, no stack messes or buffer overflow stuffâ€”and Iâ€™m so proud of how it turned out!
How I Got It All Working (It Was a Ride!)
The 68000 code was like a little puzzle I had to solve in x86_64, and hereâ€™s how I did it:

Playing with Registers:In the 68000 code, they used D1 and D2 to pass numbers to a subroutine called REGISTER_ADDER. I learned that in x86_64, you use rdi and rsi for that (thanks to this thing called the System V ABI calling conventionâ€”I felt so smart figuring that out!). The result goes into rax, just like how D1 gets updated in the original. The running total was in D3, so I used rbx for that, and for the loop counter (which was D4 in 68000), I picked r12 because I had some register conflicts before, and Iâ€™ll tell you more about that soon!

Showing Stuff and Getting Your Input:The 68000 code used TRAP #15 to print messages and get inputâ€”like MOVE.B #14, D0 to show a prompt and MOVE.B #4, D0 to grab a number. In x86_64, I used Linux syscalls instead: write (with rax set to 1) to print messages, and read (with rax set to 0) to get what you type. Oh, and the 68000â€™s SIMHALT to stop the program? I turned that into an exit syscall (rax = 60) in x86_64.

Looping 3 Times:The 68000 code set a counter to 3 (MOVE.W #3, D4), took away 1 each round (SUBQ.W #1, D4), and kept looping if it wasnâ€™t zero (BNE GAME_LOOP). I did the same in x86_64 with mov r12, 3, dec r12, and jnz game_loop. I had some trouble with this loop before, but I fixed itâ€”more on that below!


Cool Stuff I Added and Fixed
Hereâ€™s what I worked on to make this program awesome:

Added Support for Negative Numbers:I made sure the program can handle negative numbers like a champ! In the atoi function (thatâ€™s the part that turns your typed string into a number), I added a check for a minus sign (-) at the start. If it sees one, it sets a little flag (r9) to remember itâ€™s negative, skips the minus sign, and then at the end, it flips the number to be negative with neg rax. So if you type -5, itâ€™ll actually use -5, not just freak out!

Made Zero Work Better:I also improved how the program handles zero. Before, it was a bit clunky, but now in the print_number function, I added a special check for zero (test rax, rax; jnz .convert). If the number is zero, it just prints a 0 instead of getting confused. I also made sure atoi handles empty or weird input by jumping to an error case, so it safely uses 0 if somethingâ€™s off.

Fixed Register Conflicts (Big Win!):Oh my gosh, this was such a headache before! I used to use rcx for the loop counter, but rcx was also being used in my atoi and print_number functions, so the loop counter kept getting messed up, and the program wouldnâ€™t stop after 3 roundsâ€”itâ€™d just keep going! I switched to r12 for the loop counter instead, and now everything works perfectly. I also got rid of some push and pop stuff when clearing the buffer (Iâ€™ll tell you more about that in the security part!).

Made It Super Secure:Security was a big deal for this project, and I worked hard to make sure my program is safe! The 68000 code didnâ€™t check user input at all, which was super riskyâ€”like, someone could type a crazy long string and cause a buffer overflow, which might let them mess with the memory and do bad stuff. So, in my atoi function, I added a bunch of safety checks:

I made sure the input isnâ€™t longer than my buffer (16 bytes) with cmp rcx, buffer_len; jge .error.
I capped the number of digits at 20 (cmp r10, 20; ja .error) because 64-bit numbers canâ€™t handle more than 19 digits anyway, so this stops overflows.
I checked that every character is actually a digit (cmp rdx, '0'; jb .error and cmp rdx, '9'; ja .error) so junk like abc doesnâ€™t mess things up.
If the input is weird, I print â€œInvalid input! Using 0.â€ and use 0 so the program keeps going safely.For the stack, I was really careful too. My register_adder function uses registers (rdi and rsi) to pass numbers, so Iâ€™m not touching the stack there, which is awesome for avoiding stack-based problems. I used to use push and pop when clearing the buffer, but I changed that to use rep stosb with rcx instead, so Iâ€™m not using the stack at all for that part now. The only time I use the stack is in atoi when I print an error message (push rax and pop rax), but I made sure itâ€™s balanced, so itâ€™s totally safe.


Fixed That Annoying Assembly Error:I had this super frustrating issue before where Iâ€™d try to assemble my program with nasm -f elf64 sum-program.asm -o sum-program.o, and itâ€™d say sum-program.asm:1: error: parser: instruction expected. The first line was just a comment, so I was like, â€œWhat?!â€ I figured out it was probably some sneaky invisible character or a file encoding thingâ€”like a byte order mark (BOM). I recreated the file using nano, and now it assembles perfectly!


Whatâ€™s in My Project Folder
Hereâ€™s what Iâ€™ve got for you:

sum-program.asm: My main x86_64 assembly program with all the cool updates and security fixes!
test_script.c: A little C script to test the program automatically (I havenâ€™t made this yet, itâ€™s optional).
demo_video.mp4: A short video of the program running (Iâ€™m planning to record this soonâ€”Iâ€™ll show all my test cases!).

How You Can Run It
I did this on a Linux VM (like the SETU Carlow ones), and now that Iâ€™ve fixed all the issues, it runs like a dream! Hereâ€™s how you can try it:

Assemble and Link:
nasm -f elf64 sum-program.asm -o sum-program.o
ld sum-program.o -o sum-program

I fixed that â€œparser: instruction expectedâ€ error by recreating the file, so this should work perfectly now!

Run It:
./sum-program


What It Looks Like:Itâ€™ll ask you for two numbers 3 times, add them up each time, show the running total, and stop after the 3rd round with the final sum. Hereâ€™s an example if you type 1 and 1 each time:
Enter number: 1
num1: 1
Enter number: 1
num2: 1
The sum is: 2
Enter number: 1
num1: 1
Enter number: 1
num2: 1
The sum is: 4
Enter number: 1
num1: 1
Enter number: 1
num2: 1
The sum is: 6
Final sum is: 6

Iâ€™m gonna show this and more in my demo_video.mp4 soon!


What Iâ€™ve Tested So Far
Iâ€™ve tried a bunch of different things to make sure my program works great, and hereâ€™s what I found:

Normal Numbers: I typed 1 and 1 for all 3 rounds, and it worked perfectlyâ€”sums were 2, 4, 6, and it stopped right after 3 rounds like itâ€™s supposed to.
Negative Numbers: I tried -5 and 3 for the first round, then 1 and 1 for the others. It added -5 + 3 to get -2, then added 1 + 1 to get 0, then 2, and the final sum was 2. So cool that it handles negatives now!
Zero and Empty Input: I just pressed Enter (empty input) for a number, and it said â€œInvalid input! Using 0.â€ and kept going. I also tried typing 0, and it printed it correctly without any weirdness.
Silly Input: I typed abc for a number, and it said â€œInvalid input! Using 0.â€ and kept going without crashing, which shows my buffer overflow fix is working awesome.
Long Input: I typed a super long number (like 12345678901234567890) to test the buffer overflow protection, and it safely used 0 instead, keeping everything safe.

Iâ€™ll show all of these in my demo video too!
What Was Super Hard

Those Register Conflicts: Figuring out that rcx was causing my loop to go crazy was tough! Switching to r12 and fixing the buffer clearing made everything so much better.
Negative Numbers: Adding support for negative numbers in atoi took some thinkingâ€”I had to track the sign and apply it at the end, but Iâ€™m so happy with how it turned out.
Security Stuff: Making sure the program was safe from buffer overflows and stack issues was a bit scary at first, but I learned so much, and Iâ€™m really proud of how secure it is now!
That Assembly Error: That â€œparser: instruction expectedâ€ error had me so confused, but recreating the file fixed it, and I felt like a detective solving a mystery, haha!
Learning Syscalls: Switching from 68000â€™s TRAP #15 to x86_64 syscalls was a bit tricky, but I got the hang of it!

How I Can Make It Even Better

I could add a check for really big numbers in the addition partâ€”like, if the sum gets too big for a 64-bit number, I can catch it with the jo instruction and handle it.
I might write a little C script to test the program automatically, maybe using something like assert.h to check the outputs.
I could add more error messages, like if the read syscall fails, to make the program even more user-friendly.

When I Need to Finish This

Deadline: April 28, 2025, 9:00 AM (no GitHub commits after this, eek!).
Demo and Quiz: May 2, 2025, from 9:00 AM to 5:00 PM.

Iâ€™m almost doneâ€”just need to record that demo video, and Iâ€™ll be ready to submit! Thanks so much for checking out my projectâ€”youâ€™re the best! ğŸ˜Š
